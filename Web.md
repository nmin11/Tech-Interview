## GET과 POST의 차이가 뭔가요?

HTTP 메소드들 중에서 GET은 서버로부터 정보를 조회하기 위해 설계된 메소드이고,  
POST는 리소스를 생성 및 변경하기 위해 설계된 메소드입니다.

이러한 GET과 POST의 뚜렷한 차이점은 **멱등** 에 있습니다.  
멱등은 '연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질'을 뜻하는데, GET 메소드가 바로 이에 해당합니다.  
GET으로는 똑같은 요청을 여러 번 전송하더라도 동일한 응답이 돌아옵니다.  
반면에 POST로는 똑같은 요청을 여러 번 전송했을 경우 응답이 매번 다를 수 있습니다.

<br>

## HTTP와 HTTPS의 차이가 뭔가요?

우선 HTTP는 TCP/IP 위에서 작동하는 stateless 프로토콜이며, 암호화되지 않은 평문 데이터를 전송하는 프로토콜입니다.  
그리고 HTTPS는 이러한 HTTP에 데이터 암호화가 추가된 프로토콜입니다.  
HTTPS는 네트워크 상에서 제 3자가 데이터를 볼 수 없도록 하기 위해서 모두에게 공개하는 공개 키와, 나만 갖고 있는 개인 키를 사용하여 암호화를 합니다.  
이후 복호화를 할 때에는, 공개키로 암호화했다면 개인키로 복호화해야 하고, 개인키로 암호화했다면 공개키로 복호화해야 한다는 특징을 가지고 있습니다.  
그리고 또한 HTTPS를 적용하기 위해서는 사용자가 접속한 사이트가 신뢰할 수 있는 사이트라는 것을 판별할 수 있게 하기 위해서 인증된 민간 기업인 Certificate Authority, 즉, CA 기업으로부터 인증을 받아야 합니다.  
크롬, 사파리, 엣지, 파이어폭스 등의 브라우저에는 이 CA 기업들의 공개키들이 내장되어 있어서, 이 공개키를 확인하고 브라우저는 해당 사이트가 안전한 사이트인지를 판별해줍니다.

HTTPS는 이렇듯 HTTP에 비해서 암호화가 되어 있지만, 암호화 및 복호화 과정에서 시간이 조금 더 소모됩니다.  
하지만 이 속도 격차는 오늘날에는 거의 느끼지 못할 만한 수준입니다.  
그리고 HTTPS는 인증서를 발급하고 유지하는 추가 비용이 소모된다는 특징이 있습니다.

<br>

## 브라우저의 작동 원리에 대해서 설명해주세요

우선, 브라우저의 개념은, HTML, CSS, JS 언어를 해석하여 내용을 화면에 보여주는 응용 소프트웨어입니다.  
그리고 이 브라우저는 사용자 인터페이스, 브라우저 엔진, 렌더링 엔진, 통신, UI 백엔드, JavaScript 해석기, 자료 저장소 까지, 이렇게 7가지로 구성되어 있습니다.

이 중에서도 브라우저의 작동 흐름에 대해서 파악하려면 렌더링 엔진을 위주로 살펴봐야 하는데, 이 렌더링 엔진의 개념은 HTML, XML, 이미지 등 요청받은 내용을 브라우저 화면에 표시하는 엔진입니다.  
렌더링 엔진은 가능하면 빠르게 렌더링하기 위해서 일련의 과정들을 비동기적으로 진행합니다.  
이 과정으로는 우선 1번, HTML 문서를 파싱하여 DOM 트리를 구축하고,  
2번, 외부 CSS 파일과 함께 포함된 스타일 요소를 파싱합니다.  
그리고 3번, 1번의 DOM 트리와 2번의 스타일 요소를 합쳐서 렌더 트리를 구축합니다.  
그 다음으로 4번, 렌더 트리 각 노드에 대해 화면 상에서 배치할 곳을 결정합니다.  
마지막으로 5번, UI 백엔드에서 렌더 트리의 각 노드를 그립니다.

<br>

## OSI 7 Layer에 대해서 설명해주세요

OSI 7 Layer는 네트워크를 구성하는 표준 계층 중 하나입니다.  
우선 개념적으로는, 계층을 분리하여 독립적인 역할을 하게 하고, 문제가 발생하면 어떤 계층에서 문제가 생겼는지 파악하게 해주는 구조입니다.  
그리고 7개의 각 계층으로는 Physical Layer, Data Link Layer, Network Layer, Transport Layer, Session Layer, Presentation Layer, Application Layer가 있습니다.

우선 첫 번째, **Physical Layer** 는 하드웨어 전송 기술로 이루어져 있습니다.  
기계적인 신호를 비트 단위로 통신하는 역할을 하며, 대표적인 장비는 통신 케이블, 허브, 리피터 등이 있습니다.

두 번째, **Data Link Layer** 는 Point to Point 간의 신뢰성 있는 전송을 보장하기 위한 계층입니다.  
대표적인 장비는 스위치와 브릿지가 있습니다.

세 번째, **Network Layer** 는 우리가 흔히들 아는 IP 주소를 제공하는 계층입니다.  
이 계층에서는 대표적으로 각 노드들을 거칠 때마다 라우팅을 해주는 역할을 담당합니다.  
이 계층의 대표적인 장비로는 라우터, L3 스위치, IP 공유기 등이 있습니다.

네 번째, **Transport Layer** 는 End to End의 사용자들이 데이터를 주고 받을 수 있게 해주는 계층입니다.  
대표적으로 우리가 자주 사용하는 TCP와 UDP 프로토콜이 있는 계층입니다.  
전송 단위는 Segment입니다.

다섯 번째, **Session Layer** 부터는 데이터를 만들어내는 계층입니다.  
duplex나 half-duplex, full duplex의 통신과 함께, 체크 포인팅과 유휴, 종료, 다시 시작 과정 등을 수행합니다.  
그리고 이 계층은 TCP/IP 세션을 만들고 없애는 책임을 집니다.  
대표적으로는 RPC, Socket 등이 있습니다.

여섯 번째, **Presentaion Layer** 는 코드 간의 번역을 담당하여 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 이 다음 계층으로부터 덜어 줍니다.  
MIME 인코딩이나 암호화 등의 동작이 이 계층에서 이루어집니다.  
우리가 자주 사용하는 데이터의 압축이나 인코딩 등을 여기에서 다룬다고 볼 수 있습니다.

일곱 번째, **Application Layer** 는 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행합니다.  
한마디로 우리가 사용하는 사용자 인터페이스를 제공하는 프로그램 등을 뜻합니다.  
대표적으로 HTTP, FTP 등의 프로토콜이 여기에 속합니다.

<br>

## RESTful이란 용어에 대해 아시나요?

네. RESTful은 일반적으로 REST, Representational State Transfer라는 아키텍처를 구현하는 웹 서비스를 나타내기 위해 사용되는 용어입니다.  
REST API를 제공하는 웹 서비스를 RESTful하다고 할 수 있으며, 사실 RESTful은 REST를 REST 답게 사용하는 것이 주 목적이고, 누군가 발표한 것이 아닙니다.  
RESTful의 목적은 이해하기 쉽고 사용하기 쉬운 REST API를 만드는 데에 있습니다.  
성능의 향상에 초점을 두는 게 아니며, 일관적인 컨벤션을 통해 API의 이해도 및 호환성을 높이는 것이 목적입니다.

<br>

## Web Server와 WAS의 차이가 뭔가요?

우선 개념 정의 상으로 Web Server는 사용자가 웹 브라우저에서 어떤 요청을 하면 그것을 받아서  
정적인 컨텐츠를 제공하는 서버입니다.  
그리고 WAS, 즉 Web Application Server는 웹 서버와 웹 컨테이너가 합쳐진 형태로,  
DB를 사용하거나 다양한 로직 처리가 필요한 동적 컨텐츠를 제공해줍니다.  
이렇게 정적 컨텐츠를 다루는 Web Server와 동적 컨텐츠를 다루는 WAS를 따로 두고 함께 사용하면  
상호 간에 서버 부하를 줄여줄 수 있습니다.

- Reference 1 : [Web Server와 WAS의 차이와 웹 서비스 구조](https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html)
- Reference 2 : [웹 서버와 WAS의 차이를 쉽게 알아보자](https://codechasseur.tistory.com/25)

<br>

## 로드밸런서에 대해 설명해주세요

하나의 인터넷 서비스에서 발생하는 트래픽이 많을 때 여러 대의 서버를 통해 분산 처리하여  
서버의 로드율 증가, 부하량, 속도 저하 등을 고려하여 적절히 분산처리하여 해결해주는 서비스입니다.  
로드밸런서와 관련된 주요 기능으로는 NAT, Tunneling, DSR이 있는데,  
NAT는 사설 IP를 공인 IP 주소로 변경해주는 통신망의 주소 변조기이며,  
Tunneling은 통신하는 통로를 만들고 데이터를 캡슐화해서 통로를 통한 경로로만 패킷을 구별해서 캡슐을 해제할 수 있도록 합니다.  
그리고 DSR은 로드 밸런서 사용 시 서버에서 클라이언트로 되돌아가는 경우 목적지 주소를  
스위치의 IP 주소가 아닌 클라이언트의 IP 주소로 전달해서 네트워크 스위치를 거치지 않고 바로 클라이언트를 찾아가는 개념입니다.

## OAuth 2.0에 대해 설명해주세요

로그인 및 개인 정보 관리 책임을 서드파티 애플리케이션에게 위임할 수 있는 서비스입니다.  
OAuth 2.0의 요소들은 어떤 서드파티 앱을 쓰냐에 따라 차이가 있을 수 있는데,  
기본적으로는 Client, Resource Owner, Resource Server, Authorization Server로 이루어져 있습니다.  
Client는 서드파티 로그인을 구현할 본인의 애플리케이션 서버이고,  
Resource Owner는 서드파티 앱에 이미 가입된 유저이면서 동시에 Client의 서비스를 이용하려는 유저입니다.  
그리고 Resource Server는 유저 정보를 갖고 있는 서드파드 애플리케이션 서버이며,  
Client는 토큰을 이 서버로 넘겨서 개인 정보를 응답받을 수 있습니다.  
Authorization Server는 권한을 부여해주는 서버로,  
유저는 이 서버로 아이디 및 비밀번호를 넘겨서 Authorization Code를 받을 수 있습니다.  
그리고 Client는 이 서버로 Authorization Code를 넘겨서 토큰을 발급받을 수 있습니다.

(이미지 첨부)

(가능하면 보드를 이용하거나 노트를 꺼내서 그림으로 설명하겠다고 할 것)

OAuth 2.0의 작동 방식은 앞서 말씀드렸던 4개의 요소들을 토대로 이루어집니다.  
우선 Resource Owner, 즉 유저가 저희 애플리케이션에서 서드파티 앱 연동을 시도하면 서버에서 Client ID와 Redirect URI를 줍니다.  
이 2가지를 가지고 Authorzation Server, 즉 서드파티 앱 서버에 로그인 페이지를 요청하고,  
Authorization Server는 로그인 페이지를 제공해줍니다.  
그래서 유저는 로그인 페이지에서 로그인을 하면 Authorization Server는 Authorization Code를 발급해줍니다.  
유저는 이렇게 받은 코드를 다시 Client, 즉 저희 앱 서버에 Redirect URI를 통해서 전달해줍니다.  
그러면 Client는 다시 Authorization Server에 Access Token을 요청하고 토큰을 응답 받습니다.  
토큰까지 발급 받고 나면 유저는 인증 및 로그인에 성공하게 되고,  
이후 서비스를 요청할 때마다 Access Token을 통해 Authorization Code를 검증하면서 서비스를 제공할 수 있게 됩니다.  
그리고 Access Token을 발급 받을 때 보통 Refresh Token을 함께 발급받아서  
Access Token의 유효 시간이 끝나면 Refresh Token을 통해 Access Token을 재발급받습니다.

- Reference : [OAuth 2.0 개념 정리](https://hwannny.tistory.com/92)
