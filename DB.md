## Transaction에 대해서 설명해주세요

Transaction이란 데이터베이스의 상태를 변경시키기 위해 수행하는 작업 단위입니다.  
그리고 트랜잭션에는 4가지 특징이 있는데,  
DB에 모두 반영되거나 전혀 반영되지 않아야 한다는 원자성과,  
작업 처리의 결과가 항상 일관되어야 한다는 일관성,  
하나의 트랜잭션은 다른 트랜잭션에 끼어들 수 없다는 독립성,  
트랜잭션이 성공적으로 완료되었을 경우 영구적으로 결과에 반영되어야 한다는 지속성입니다.  
트랜잭션은 기본적으로 Commit 과 Rollback 이라는 개념으로 이러한 4가지 특징을 다루는데요,  
Commit은 하나의 트랜잭션이 성공적으로 끝나서 데이터베이스가 일관성 있는 상태에 있음을 뜻하고,  
Rollback은 하나의 트랜잭션 처리가 비정상적으로 종료되었을 때의 상태를 뜻합니다.  
Rollback 이 발생하면 트랜잭션을 재실행하거나 취소할 수 있게 됩니다.

<br>

## RDBMS와 NoSQL의 차이점을 설명해주세요

RDBMS의 저장 방식은 SQL을 사용해야 하며, 정해진 스키마에 따라 데이터를 저장하는 방식입니다.  
모든 데이터를 2차원 테이블 형태로 표현할 수 있도록 저장하게 됩니다.  
그리고 RDBMS가 또 한 가지 NoSQL과 구별되는 특징은 외래키를 사용한다는 점입니다.  
RDBMS를 사용하면 외래키를 이용해서 테이블 간 join이 가능해집니다.

<br>

반면에 NoSQL은 테이블 간 관계를 정의하지 않고 테이블은 그냥 하나의 테이블이기에 join이 불가능합니다.  
다만 현재 NoSQL이 각광 받는 이유는 빅데이터의 등장으로 데이터와 트래픽이 기하급수적으로 증가하고 있는데,  
RDBMS에서는 이러한 문제점을 해결하기 위해서는 비용이 기하급수적으로 많이 드는 Scale-Up을 시도할 수 밖에 없습니다.  
하지만 여기서 NoSQL을 사용하게 되면 데이터의 일관성은 포기하되,  
비용을 고려한 여러 대의 데이터에 분산하여 저장하는 Scale-Out 확장 방식이 가능해집니다.

<br>

## DB index에 대해서 설명해주세요

추가적인 쓰기 작업과 저장 공간을 활용해서 테이블에 대한 검색 속도를 향상시키기 위한 자료구조입니다.  
마치 책에 끼워두는 색인, 혹은 데이터의 특정 부분에 대한 사본이라고도 볼 수 있습니다.  
만약 인덱스를 사용하지 않는다면 조회를 위해서 데이터 전체를 Full Scan을 해야 하기 때문에  
당연히 조회 성능상의 차이가 발생합니다.  
인덱스는 조회 성능에 초점을 두고 있지만, 사실 UPDATE나 DELETE할 때에도,  
우선 조회를 하고 나서 데이터를 갱신하거나 삭제하게 되기 때문에 다른 기능의 성능도 함께 상향됩니다.  
인덱스의 장단점을 살펴보자면,  
우선 장점은 역시 조회 성능을 높일 수 있다는 점과 함께,  
전반적인 시스템의 부하를 줄일 수 있다는 점이 있습니다.  
그리고 단점으로는 이 인덱스를 관리하기 위해 DB에서 약 10% 정도의 저장공간을 할애해야 하고,  
인덱스를 관리하기 위한 추가 작업이 필요하며, 잘못 사용하면 오히려 성능이 저하될 수가 있습니다.  
CRUD 작업이 빈번한 속성에 인덱스를 걸면 인덱스의 크기가 비대해져서 오히려 성능이 저하됩니다.  
따라서 인덱스는 규모가 큰 DB에서 조회 위주의 업무만 수행하는,  
JOIN이나 WHERE, ORDER BY에 대한 조건으로 주로 사용되는 컬럼에 사용해주는 것이 적절합니다.  
인덱스는 또한 레코드 접근과 관련해서 효율적인 순서 매김 관련 알고리즘을 제공합니다.  
알고리즘의 종류에는 B-tree Index, Bitmap Index, IOT Index, Clustered Index 등이 있으며,  
주로 사용되는 것은 B-tree 구조입니다.

- Reference 1 : [DB Indexing이란?](https://velog.io/@bsjp400/Database-DB-%EC%9D%B8%EB%8D%B1%EC%8B%B1Indexing%EC%9D%B4%EB%9E%80)
- Reference 2 : [index란?](https://mangkyu.tistory.com/96)
