## 영속성 컨텍스트에 대해서 설명해주세요

영속성 컨텍스트는 Entity를 영구 저장하는 환경이라는 뜻이며,  
애플리케이션과 DB 사이에서 객체를 보관하는 가상 DB 역할을 합니다.  
Entity Manager를 통해 Entity를 저장하거나 조회하면  
Entity Manager는 영속성 컨텍스트에 Entity를 보관하고 관리합니다.

<br>

Entity의 생명주기는 4가지인데 바로 비영속, 영속, 준영속, 삭제입니다.  
비영속은 Entity 객체를 생성했지만 아직 영속성 컨텍스트에 저장하지 않은 상태입니다.  
그리고 영속은 Entity Manager를 통해 Entity를 영속성 컨텍스트에 저장한 상태입니다.  
준영속은 영속성 컨텍스트에서 분리된 상태의 Entity입니다.  
준영속의 특징은 영속성 컨텍스트의 어떤 기능도 동작하지 않지만 식별자 값을 가지고 있습니다.  
그리고 삭제는 Entity가 영속성 컨텍스트와 DB에서 모두 삭제된 상태입니다.

<br>

영속성 컨텍스트의 특징이 몇 가지 있는데,
우선 Entity를 식별자 값으로 구분한다는 점입니다.  
따라서 영속 상태의 Entity는 식별자 값이 반드시 있어야만 합니다.  
그리고 JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트의 Entity를  
DB에 반영하는데, 이를 flush라고 합니다.

<br>

영속성 컨텍스트의 장점은 우선  
첫 번째로 1차 캐시라는 것을 사용하는데, 이는 영속성 컨텍스트 내부의 캐시입니다.  
영속 상태의 Entity를 이 1차 캐시에 저장하는데, 1차 캐시는 키가 식별자 값이고,  
값은 Entity 인스턴스로 이루어져 있습니다.  
JPA에서 조회를 할 때 이 1차 캐시를 먼저 조회하고 그 다음에 DB를 조회하기 때문에  
리소스 낭비를 줄여줄 수 있습니다.  
두 번째 장점으로는 영속 Entity의 동일성을 보장한다는 점입니다.  
동일한 식별자 값을 통해서 찾아낸 Entity는 서로 같다는 것을 보장해줍니다.  
그리고 세 번째가 '트랜잭션을 지원하는 쓰기 지연'입니다.  
Entity Manager는 트랜잭션을 커밋하기 전에 내부 쿼리 저장소에 INSERT 쿼리들을 모아둡니다.  
그리고 트랜잭션을 커밋하면 이 때 모아둔 쿼리들을 DB에 보내게 됩니다.  
네 번째 장점으로는 변경 감지가 있습니다. Dirty Checking이라고도 하죠.  
JPA는 Entity를 수정하기 위해서 단순히 Entity를 조회하고 그 데이터를 변경하기만 하면 됩니다.  
그렇게만 하면 알아서 Entity와 스냅샷을 비교하여 변경된 Entity를 찾아내고,  
변경된 부분이 있다면 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 저장하기 때문에  
수정을 위한 별도의 다른 작업이 필요하지 않습니다.

<br>

## SQL의 distinct와 JPQL의 distinct는 뭐가 다른가요?

SQL의 distinct는 중복된 결과를 제거하는 명령입니다.  
이 경우 모든 컬럼 값이 일치해야 중복을 제거해주는 특성을 가집니다.  
이에 반해 JPQL의 distinct는 애플리케이션 상에서 동일한 식별자를 가진  
Entity를 제거해주기 때문에 좀 더 ORM 특성에 맞게 중복을 제거해줄 수 있습니다.
